"""
entity_creation.py
Purpose: Generates city, personas, objects, and names for simulation. Orchestrates creation of world data and outputs YAML summaries.
Key Functions: create_world, create_city, create_personas, create_object, create_names
LLM Usage: Uses LLM for persona and object generation.
"""

from datetime import datetime

def create_world(args):
    print(f"[entity_creation] Creating world for city: {args.city}")
    personas_path = getattr(args, 'personas', 'configs/personas.yaml')
    city_out = getattr(args, 'city_out', 'configs/city.yaml')
    num_personas = getattr(args, 'num_personas', 20)
    seed = getattr(args, 'seed', 42)
    start_year = getattr(args, 'start_year', 1900)
    # Step 1: Generate city
    create_city(argparse.Namespace(city=args.city, start_year=start_year, seed=seed))
    # Step 2: Generate personas using city places
    city_places = []
    if os.path.exists(city_out):
        with open(city_out, 'r', encoding='utf-8') as f:
            city_data = yaml.safe_load(f)
        city_places = city_data.get('places', [])
    create_personas(argparse.Namespace(city=args.city, num=num_personas, out=personas_path, seed=seed, places=city_places))
    # Step 3: Write world.yaml with start_year and comment
    project_root = os.path.dirname(os.path.abspath(__file__))
    world_yaml_path = os.path.join(project_root, "configs", "world.yaml")
    comment = f"# Generated by entity_creation.py on {datetime.now().strftime('%Y-%m-%d')}\n"
    world_data = {"city": args.city, "start_year": start_year}
    with open(world_yaml_path, "w", encoding="utf-8") as f:
        f.write(comment)
        yaml.safe_dump(world_data, f, allow_unicode=True, sort_keys=False)
    print(f"[entity_creation] Set start_year to {start_year} in {world_yaml_path}")
    # Step 4: Output summary report
    num_places = len(city_places)
    num_connections = 0
    if os.path.exists(city_out):
        with open(city_out, "r", encoding="utf-8") as f:
            city_data = yaml.safe_load(f)
        num_connections = len(city_data.get("connections", []))
    num_personas_final = 0
    if os.path.exists(personas_path):
        with open(personas_path, "r", encoding="utf-8") as f:
            personas_data = yaml.safe_load(f)
        num_personas_final = len(personas_data.get("people", []))
    print("[entity_creation] Summary Report:")
    print(f"  Places: {num_places}")
    print(f"  Connections: {num_connections}")
    print(f"  Personas: {num_personas_final}")
    print("[entity_creation] World generation complete.")
import argparse
import sys
import os
import argparse
import sys
import os
import yaml
import json
import random
from sim.llm.llm_ollama import LLM

# --- City Creation ---
def ensure_rng(rng):
    return rng if rng is not None else random

def load_names():
    with open("configs/World_0/names.yaml", "r", encoding="utf-8") as f:
        names_data = yaml.safe_load(f)
    return names_data.get("first_names", []), names_data.get("last_names", [])

def create_city(args):
    cityname = args.city
    start_year = args.start_year
    seed = getattr(args, 'seed', 42)
    rng = ensure_rng(None)
    config_path = "configs/city_default_place_roles.yaml"
    protopersonas = []
    used_names = set()
    first_names, last_names = load_names()
    print(f"[entity_creation] Creating city: {cityname} (year {start_year})")
    # Try to load default places and roles from config file
    if os.path.exists(config_path):
        print(f"[entity_creation] Loading default places and roles from {config_path}")
        with open(config_path, "r", encoding="utf-8") as f:
            default_places = yaml.safe_load(f)
        city_data = {"places": default_places}
    else:
        print(f"[entity_creation] Generating default places and roles and saving to {config_path}")
        # Placeholder for city.generate_default_places
        city_data = {"places": []}
        # ...additional logic as needed...
    print(f"[entity_creation] City creation complete.")

# --- Persona Creation ---
def create_personas(args):
    city = args.city
    n = getattr(args, 'num', 20)
    out = getattr(args, 'out', "configs/personas.yaml")
    seed = getattr(args, 'seed', None)
    print(f"[entity_creation] Creating {n} personas for city: {city}")
    world_yaml_path = "configs/world.yaml"
    start_year = 1900
    if os.path.exists(world_yaml_path):
        with open(world_yaml_path, "r", encoding="utf-8") as f:
            world_data = yaml.safe_load(f) or {}
            start_year = world_data.get("start_year", 1900)
    max_runs = int(n / 5.0) + 100
    people = []
    runs = 0
    default_locations = [
        f"{city} City Hall", f"{city} Central Park", f"{city} Library", f"{city} General Hospital", f"{city} Elementary School",
        f"{city} Police Station", f"{city} Community Center", f"{city} Main Bakery", f"{city} Popular Restaurant", f"{city} Public Pool"
    ]
    if seed is not None:
        random.seed(seed)
    available_places = default_locations
    used_places = set()
    llm = LLM(gen_model="llama3.1:8b-instruct-q4_0")
    while len(people) < n and runs < max_runs:
        prompt = f"""Generate personas for city: {args.city}, year: {args.start_year}. Return JSON only."""
    print(f"Creating object from schema: {args.schema}")
    # ...existing logic from make_object.py...
            # ...existing code for persona creation...


# --- Object Creation ---
def filljsonproperty(property, llm):
    prop_type = property.get("type")
    prompt_text = f"Generate a valid example value for this property schema: {json.dumps(property)}. Return only the value, no explanation."
    value = llm.chat_json(prompt_text, max_tokens=128)
    if isinstance(value, dict) and "value" in value:
        return value["value"]
    if isinstance(value, (str, int, float, bool, list, dict)):
        return value
    if prop_type == "string":
        return "example string"
    if prop_type == "number":
        return 42
    if prop_type == "boolean":
        return True
    if prop_type == "array":
        item_schema = property.get("items", {})
        return [filljsonproperty(item_schema, llm)]
    if prop_type == "object":
        props = property.get("properties", {})
        return {k: filljsonproperty(v, llm) for k, v in props.items()}
    return None

def create_object_instance(schema, llm):
    properties = schema.get("properties", {})
    obj_instance = {}
    for prop, details in properties.items():
        obj_instance[prop] = filljsonproperty(details, llm)
    return obj_instance

def create_object(args):
    print(f"[entity_creation] Creating object from schema: {args.schema}")
    with open(args.schema, "r", encoding="utf-8") as f:
        object_data = json.load(f)
    llm = LLM(gen_model="llama3.1:8b-instruct-q4_0")
    response = create_object_instance(object_data, llm)
    print("Generated Object Instance:", response)

def timeout_heuristic(num_names, batch_size=100):
    base = 94
    per_name = base / batch_size
    timeout = int(per_name * num_names)
    timeout = ((timeout + 9) // 10) * 10
    return max(30, timeout)

def base_name_prompt(kind: str, n: int, city: str, year: int, exclude_str: str):
    if kind == "first":
        label = "first_names"
        expert = "historical names"
        example = "John1, John2"
        system_prompt = (
            f"You are an expert in {expert}. You generate lists of unique, realistic first names appropriate for residents of a given city and year. "
            f"Names must be authentic to the time and place, and should be highly diverse, including international, rare, and less common names, as well as names from minority groups. "
            f"Do NOT repeat, use numeric suffixes, or use modern/international outliers inappropriate for the year. "
            f"Each name must be a single word (no spaces). Avoid using the same name with numbers (e.g., {example}). "
            f"For each name, always include a 'sex' field: 'male', 'female', or 'unisex'."
        )
        user_prompt = (
            f"Generate a list of {n} unique and highly diverse first names for {city} in {year}. Include international, rare, and minority names. Exclude these names: [{exclude_str}]. "
            "Return ONLY a JSON array in the following format: {first_names: [ {name: '...', sex: 'male|female|unisex'}, ... ] }"
        )
    else:
        label = "last_names"
        expert = "historical surnames"
        example = "Smith1, Smith2"
        system_prompt = (
            f"You are an expert in {expert}. You generate lists of unique, realistic last names appropriate for residents of a given city and year. "
            f"Names must be authentic to the time and place, diverse, and should NOT repeat, use numeric suffixes, or be modern/international outliers. "
            f"Each name must be a single word (no spaces). Avoid using the same name with numbers (e.g., {example})."
        )
        user_prompt = (
            f"Generate a list of {n} unique last names for {city} in {year}. Exclude these names: [{exclude_str}]. "
            f"Return ONLY a JSON array: {{{label}: [name1, name2, ...]}}"
        )
    return system_prompt, user_prompt, label

def generate_names(kind: str, city: str, year: int, num_names: int, seed: int, rng=None, max_tokens=6000, timeout=None, batch_size=100, excluded_names=None):
    if rng is None:
        rng = random
    names = []
    excluded = set(excluded_names) if excluded_names else set()
    label = "first_names" if kind == "first" else "last_names"
    batch_num = 1
    retries = 0
    llm = LLM(gen_model="llama3.1:8b-instruct-q4_0")
    while len(names) < num_names:
        n = batch_size
        exclude_str = ', '.join(sorted(excluded))
        system_prompt, user_prompt, label = base_name_prompt(kind, n, city, year, exclude_str)
        llm_seed = seed if seed is not None else rng.randint(-5000,5000)
        print(f"[DEBUG] Batch {batch_num}: Requesting {n} names, {len(names)} collected so far. Excluded: {len(excluded)}")
        batch_names = llm.chat_json(user_prompt, system=system_prompt, seed=llm_seed, max_tokens=max_tokens, timeout=timeout).get(label, [])
        new_names = []
        if not batch_names or not isinstance(batch_names, list):
            print(f"[DEBUG] Batch {batch_num}: LLM returned no valid list.")
            batch_num += 1
        else:
            if kind == "first":
                for entry in batch_names:
                    if (
                        isinstance(entry, dict)
                        and 'name' in entry
                        and 'sex' in entry
                        and isinstance(entry['name'], str)
                        and entry['name'] not in excluded
                        and entry['sex'] in ['male', 'female', 'unisex']
                        and len(entry['name'].split()) == 1
                    ):
                        new_names.append(entry)
            else:
                for name in batch_names:
                    if name not in excluded and isinstance(name, str) and len(name.split()) == 1:
                        new_names.append(name)
        print(f"[DEBUG] Batch {batch_num}: {len(new_names)} new names added.")
        if new_names:
            to_add = new_names[:num_names - len(names)]
            if kind == "first":
                names.extend(to_add)
                excluded.update([entry['name'] for entry in to_add])
            else:
                names.extend(to_add)
                excluded.update(to_add)
            batch_num += 1
        else:
            if retries >= 3:
                print(f"[DEBUG] No new names found in batch {batch_num} after {retries} retries. Stopping.")
                break
            print(f"[DEBUG] No new names found in batch {batch_num}. Retrying (attempt {retries+1}/3).")
            retries += 1
    print(f"[DEBUG] Total names collected: {len(names)}")
    if kind == "first":
        return sorted(names, key=lambda x: x['name'])
    else:
        return sorted(names)

def create_names(args):
    print(f"[entity_creation] Generating names for city: {args.city}, year: {args.year}")
    num_first = getattr(args, 'num_first', 500)
    num_last = getattr(args, 'num_last', 500)
    seed = getattr(args, 'seed', 42)
    out = getattr(args, 'out', 'configs/names.yaml')
    max_tokens = getattr(args, 'max_tokens', 2000)
    timeout = getattr(args, 'timeout', None)
    batch_size = getattr(args, 'batch_size', 100)
    rng = random.Random(seed)

    existing_first_names = []
    existing_last_names = []
    if os.path.exists(out):
        with open(out, 'r', encoding='utf-8') as f:
            try:
                names_data = yaml.safe_load(f)
                ef = names_data.get('first_names', [])
                el = names_data.get('last_names', [])
                for fn in ef:
                    if isinstance(fn, dict) and 'name' in fn and 'sex' in fn:
                        existing_first_names.append(fn)
                    elif isinstance(fn, str):
                        existing_first_names.append({'name': fn, 'sex': 'unisex'})
                for ln in el:
                    if isinstance(ln, str):
                        existing_last_names.append(ln)
            except Exception as e:
                print(f"[WARNING] Could not parse existing names.yaml: {e}")

    if timeout is None:
        timeout = timeout_heuristic(max(num_first, num_last), batch_size=batch_size)
    print(f"Heuristic timeout for {max(num_first, num_last)} names: {timeout} seconds")

    excluded_first = sorted([fn['name'] for fn in existing_first_names if 'name' in fn])
    excluded_last = sorted(existing_last_names)

    first_names = generate_names('first', args.city, args.year, num_first, seed, rng=rng, max_tokens=max_tokens, timeout=timeout, batch_size=batch_size, excluded_names=excluded_first)
    last_names = generate_names('last', args.city, args.year, num_last, seed, rng=rng, max_tokens=max_tokens, timeout=timeout, batch_size=batch_size, excluded_names=excluded_last)

    with open(out, 'w', encoding='utf-8') as f:
        yaml.safe_dump({'first_names': first_names, 'last_names': last_names}, f, allow_unicode=True, sort_keys=False)
    print(f"[entity_creation] Names saved to {out}.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Entity Creation CLI")
    subparsers = parser.add_subparsers(dest="command")

    # City
    city_parser = subparsers.add_parser("city")
    city_parser.add_argument('--city', default='Lumière')
    city_parser.add_argument('--start_year', type=int, default=1900)
    city_parser.set_defaults(func=create_city)

    # Personas
    personas_parser = subparsers.add_parser("personas")
    personas_parser.add_argument('--city', default='Lumière')
    personas_parser.add_argument('--num', type=int, default=20)
    personas_parser.set_defaults(func=create_personas)

    # Object
    object_parser = subparsers.add_parser("object")
    object_parser.add_argument('--schema', required=True)
    object_parser.set_defaults(func=create_object)

    # Names
    names_parser = subparsers.add_parser("names")
    names_parser.add_argument('--city', default='Lumière')
    names_parser.add_argument('--year', type=int, default=1900)
    names_parser.set_defaults(func=create_names)

    # World
    world_parser = subparsers.add_parser("world")
    world_parser.add_argument('--city', default='Lumière')
    world_parser.set_defaults(func=create_world)

    args = parser.parse_args()
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()
